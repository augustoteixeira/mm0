delimiter $ ( ) ~ { } $;
strict provable sort wff;
term wi (ph ps: wff): wff; infixr wi: $->$ prec 25;
term wn (ph: wff): wff; prefix wn: $~$ prec 40;

axiom ax_1 (ph ps: wff): $ph -> ps -> ph$;
axiom ax_2 (ph ps ch: wff): $(ph -> (ps -> ch)) -> ((ph -> ps) -> (ph -> ch))$;
axiom ax_3 (ph ps: wff): $(~ph -> ~ps) -> ps -> ph$;
axiom ax_mp (ph ps: wff): $ph$ > $ph -> ps$ > $ps$;


--| Expand a proof into a string
do {(def (expand p) (begin (have 'expanded-term p) (pp @ infer-type 'expanded-term)))};

-- improve didactics
theorem a1i (ph ps: wff) (h: $ph$): $ps -> ph$ = (
  focus
  --(display @ expand '(! ax_mp ph $ps -> ph$ h (! ax_1 ph ps)))
  '(! ax_mp ph $ps -> ph$ h (! ax_1 ph ps))
);

-- get inferences (just use ax_mp)
theorem a1ii (ph ps: wff) (h: $ph$): $ps -> ph$ = '(ax_mp h ax_1);
theorem a2i (ph ps: wff) (h: $ph -> ps -> ch$): $(ph -> ps) -> (ph -> ch)$ = '(ax_mp h ax_2);
theorem a3i (ph ps: wff) (h: $~ph -> ~ps$): $(ps -> ph)$ = '(ax_mp h ax_3);

theorem mpd (ph ps: wff) (h1: $ ph -> ps $) (h2: $ ph -> ps -> ch$): $ ph -> ch $ = '(ax_mp h1 (a2i h2));
theorem syl (ph ps: wff) (h1: $ph -> ps$) (h2: $ps -> ch$): $ph -> ch$ = '(
  mpd h1 (a1i h2)
);

-- get deduction style (just use syl)
theorem a1d (ph ps ch: wff) (h: $ph -> ps$): $ph -> (ch -> ps)$ = '(syl h ax_1);
theorem a2d (ph ps ch th: wff) (h: $ph -> (ps -> (ch -> th))$): $ph -> ((ps -> ch) -> (ps -> th))$ = '(syl h ax_2);
theorem a3d (ph ps ch: wff) (h: $ph -> (~ps -> ~ch)$): $ph -> (ch -> ps)$ = '(syl h ax_3);

theorem id: $ph -> ph$ = (
  focus
  (have 'h1 $ph -> (ph -> ph)$ 'ax_1)
  (have 'h2 $ph -> ((ph -> ph) -> ph)$ 'ax_1)
  '(mpd h1 h2)
);

--theorem pm2_21ii (ph ps: wff) (h: $~ph$): $ph -> ps$ = '(a3i a1i);

do {
  (def (claim label exp p)
    (begin
      --(display @ pp label)
      --(display @ pp exp)
      --(have 'label exp p)
      --(display @ pp @ infer-type 'label)
      (if (not @ == exp (infer-type 'label))
          (error "expressions do not match")
      )
      ))
};

--| contradiction implies anything
theorem pm2_21i (ph ps: wff) (h: $~ph$): $ph -> ps$ = (
  focus
  -- uncommenting display below breaks the proof :(
  -- (display @ expand 'a1i)
  -- (display @ expand '(! a1i $~ph$ $~ps$ h))
  (have 'c $~ps -> ~ph$ '(a1i h))  -- remove h here and see how the error is uninformative
  --(have 'd $ph -> ps$ '(! a3i ps ph c))
  --(display @ pp @ local-ctx)
  --(stat)
  --(claim 'c $~ps -> ~ph$ '(a1i h))  -- remove h here and see how the error is uninformative
  '(a3i c)
  --(have 'd $ph -> ps$ '(! a3i ps ph c))
  --'d
);

--| contradiction deduction style
-- just use deduction style everywhere
theorem pm2_21d (ph ps ch: wff) (h: $ph -> ~ps$): $ph -> ps -> ch$ = (
  focus
  (have 'c $ph -> (~ch -> ~ps)$ '(! a1d $ph$ $~ps$ $~ch$ h))
  '(a3d c) -- a simpler proof '(a3d (a1d h))
);

--| contradiction deduction style
-- just use deduction style everywhere
theorem _ (ph ps ch: wff) (h: $ph -> ~ps$): $ph -> ps -> ch$ = (
  focus
  -- it is difficult to use set-goals:
  --(display @ pp @ get-goals)
  --(let ([g (hd @ get-goals)]) (set-goals (ref! @ goal $ph -> (~ch -> ~ps)$) g)) -- (goal $ph -> (~ch -> ~ps)$))
  --(refine '(a1d h))
  --(have 'c $ph -> (~ch -> ~ps)$ '(! a1d $ph$ $~ps$ $~ch$ h))
  (have 'c $ph -> (~ch -> ~ps)$ '(a1d h))
  '(a3d c)
  -- a simpler proof: '(a3d (a1d h))
);

--| contradiction deduction
theorem contradiction (ph ps: wff): $~ph -> ph -> ps$ = (
  focus
  (have 'c1 $~ph -> ~ph$ 'id)
  (have 'c2 $~ph -> ph -> ps$ '(pm2_21d id)) -- again, remove id here and see the bad error message
  'c2
);

--| absorbing redundant antecedent
theorem pm2_43i (ph ps: wff) (h: $ph -> ph -> ps$): $ph -> ps$ = (
  focus
  (have 'c $ph -> ph$ 'id)
  '(mpd c h)
);


-- mirabilis: pm2.18
theorem pm2_18 (ph ps: wff): $(~ph -> ph) -> ph$ = (
  focus
  (have 'c1 $~ph -> ph -> ~(~ph -> ph)$ '(! contradiction $ph$ $~(~ph -> ph)$))
  (have 'c2 $(~ph -> ph) -> (~ph -> ~(~ph -> ph))$ '(a2i c1))
  (have 'c3 $(~ph -> ph) -> (~ph -> ph) -> ph$ '(a3d c2))
  '(pm2_43i c3)
);

-- improve proof
--| elimiation of a nested antecedent
theorem jarli (ph ps ch: wff) (h: $(ph -> ps) -> ch$): $~ph -> ch$ = '(syl contradiction h);

--| notnotr
theorem notnotr (ph: wff): $~~ph -> ph$ = (
  focus
  (have 'c $(~ph -> ph) -> ph$ '(! pm2_18 _ $ph$))
  '(jarli c)
); -- remove the semicolon and the error goes down :(

-- con1i (try using notnotr directly instead of fkn nsyl2)
-- con1d?

-- otherwise go through:
-- mto (perhaps with not phi instead)
-- mt3d

theorem notnot (ph: wff): $ph -> ~~ph$ = (
  focus
  (have 'c $~~~ph -> ~ph$ 'notnotr)
  '(a3i c)
);

--| contra
--theorem contra (ph ps: wff) (h: $~ph -> ps$): $~ps -> ph$ = (
--  focus
--  ()
--)

--| simplification
theorem simpli (ph ps: wff): $~(ph -> ps) -> ph$ = (
  focus
  (have 'c1 $~ph -> ph -> ps$ 'contradiction)
  (have 'c2 $(ph -> ps) -> ~~(ph -> ps)$ 'notnot)
  (have 'c3 $~ph -> ~~(ph -> ps)$ '(syl c1 c2))
  '(a3i c3)
);



def wb (ph ps: wff): wff = $~((ph -> ps) -> ~(ps -> ph))$;
infixl wb: $<->$ prec 20;

-- biimp
theorem bi1 (ph ps: wff): $(ph <-> ps) -> ph -> ps$ = 'simpli;


--theorem bi2 (ph ps: wff): $ (ph <-> ps) -> ps -> ph $;
--theorem bi3 (ph ps: wff): $ (ph -> ps) -> (ps -> ph) -> (ph <-> ps) $;

